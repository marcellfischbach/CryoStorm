= csMOC


== Functions

All methods that are annotated with `CS_FUNCTION()` will generate java binding code.

=== Avoid java binding

If Java bindings are not needed or the binding convention is too complicated you can
disable generation of java bindings with `CS_FUNCTION(noJava)`.



== Calling conventions

=== Method arguments

Method arguments are converted based on the following table.

[cols="1,1"]
|===
| C++ | JNI binding

| bool | jboolean

| int8_t | jbyte
| uint8_t | jshort

| int16_t | jshort
| uint16_t | jint

| int32_t | jint
| uint32_t | jlong

| int64_t | jlong
| uint64_t | WARNING!! jlong with data loss


| float | jfloat
| double | jdouble

| std::string/string | jstring
| csVector2f | jfloat, jfloat
| csVector3f | jfloat, jfloat, jfloat
| csVector4f | jfloat, jfloat, jfloat, jfloat
| csVector2i | jint, jint
| csVector3i | jint, jint, jint
| csVector4i | jint, jint, jint, jint
| csColor4f | jfloat, jfloat, jfloat, jfloat
| csMatrix3 | jfloatArray
| csMatrix4 | jfloatArray

| * ptr of any size | jlong

|===

=== Method return types

Method return types are converted a bit more complex.

Single value scalar types are converted like method arguments

[cols="1,1"]
|===
| C++ | JNI binding

| bool | jboolean

| int8_t | jbyte
| uint8_t | jshort

| int16_t | jshort
| uint16_t | jint

| int32_t | jint
| uint32_t | jlong

| int64_t | jlong
| uint64_t | WARNING!! jlong with data loss


| float | jfloat
| double | jdouble

| std::string/string | jstring

| * ptr of any size | jlong

|===

Complex/compound data types are converted via output variables (currently )

[cols="1,1"]
|===
| C++ | JNI binding

| csVector2f | jfloatArray
| csVector3f | jfloatArray
| csVector4f | jfloatArray
| csColor4f | jfloatArray
| csMatrix3 | jfloatArray
| csMatrix4 | jfloatArray

| csVector2i | jintArray
| csVector3i | jintArray
| csVector4i | jintArray

|===

E.g. a class like the following

[source,c++]
----
CS_CLASS(jclass="org.package.SomeType")
class SomeType : CS_SUPER(iObject)
{
    //...

    CS_FUNCTION()
    const csVector3f &GetVector () const;

    CS_FUNCTION()
    void SetVector(const csVector3f &vec);

    //...
};

----

will translate into jni code like

[source,C]
----
void Java_org_package_SomeType_nGetVector(JNIEnv env, jclass cls, jlong ref, jfloatArray out)
{
    // ...
}

void Java_org_package_SomeType_nSetVector(JNIEnv env, jclass cls, jlong ref, jfloat arg0, jfloat arg1, jfloat arg2)
{
    // ...
}

----

